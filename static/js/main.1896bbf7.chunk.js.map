{"version":3,"sources":["menu.js","triangle.js","serviceWorker.js","index.js"],"names":["gui","dat","closeOnTop","toggleHide","configuration","perspectiveCamera","add","listen","name","renderTriangle","orbit","scene","THREE","position","base","offset","x","y","z","phongMaterial","color","Object","assign","emissive","side","flatShading","isTilted","camera","Math","abs","sin","rotation","cos","origin","colors","window","innerWidth","innerHeight","set","PI","makePerspectiveCamera","orthographicCamera","lookAt","zoom","updateProjectionMatrix","makeOrthographicCamera","renderer","antialias","setPixelRatio","devicePixelRatio","setSize","setClearColor","document","body","appendChild","domElement","makeRenderer","lights","forEach","light","addLights","makeGroup","size","data","objectSpread","widthSegments","heightSegments","depthSegments","group","geometry","width","height","depth","cubeMaterialArray","push","coloredMesh","addBeams","makeTile","_ref","mat","plane","addCorrectingTiles","handleClick","event","isOrthographicCamera","handleDoubleClick","handleResize","aspect","addEventListener","keyCode","render","requestAnimationFrame","isPerspectiveCamera","OrbitControls","enableZoom","Boolean","location","hostname","match","onload","navigator","serviceWorker","ready","then","registration","unregister"],"mappings":"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","file":"static/js/main.1896bbf7.chunk.js","sourcesContent":["import * as dat from \"dat.gui\";\n\nconst gui = new dat.GUI({\n  closeOnTop: true\n});\ndat.GUI.toggleHide();\nconst configuration = { perspectiveCamera: false };\nconst cameraController = gui.add(configuration, \"perspectiveCamera\").listen();\ncameraController.name(\"Perspective camera\");\n\nexport { configuration };\n","import * as THREE from \"three\";\nimport OrbitControls from \"three-orbitcontrols\";\nimport { configuration } from \"./menu\";\n\nexport const renderTriangle = () => {\n  const scene = new THREE.Scene();\n\n  const position = (base, offset) => ({\n    x: (base.x || 0) + (offset.x || 0),\n    y: (base.y || 0) + (offset.y || 0),\n    z: (base.z || 0) + (offset.z || 0)\n  });\n\n  const makePerspectiveCamera = () => {\n    const perspectiveCamera = new THREE.PerspectiveCamera(\n      45,\n      window.innerWidth / window.innerHeight,\n      1,\n      5000\n    );\n    perspectiveCamera.position.set(25, 25, 25);\n    perspectiveCamera.rotation.set(-Math.PI / 4, 0, 0);\n    return perspectiveCamera;\n  };\n\n  const makeOrthographicCamera = () => {\n    const orthographicCamera = new THREE.OrthographicCamera(\n      window.innerWidth / -2,\n      window.innerWidth / 2,\n      window.innerHeight / 2,\n      window.innerHeight / -2,\n      1,\n      5000\n    );\n    orthographicCamera.position.set(30, 30, 30);\n    orthographicCamera.lookAt(new THREE.Vector3(5, 5, 5));\n    orthographicCamera.zoom = 30;\n    orthographicCamera.rotation.z = Math.PI;\n    orthographicCamera.updateProjectionMatrix();\n\n    return orthographicCamera;\n  };\n\n  const makeRenderer = () => {\n    const renderer = new THREE.WebGLRenderer({ antialias: true });\n    renderer.setPixelRatio(window.devicePixelRatio);\n    renderer.setSize(window.innerWidth, window.innerHeight);\n    renderer.setClearColor(0xffff9d, 1);\n    document.body.appendChild(renderer.domElement);\n    return renderer;\n  };\n\n  const addLights = () => {\n    var lights = [];\n    lights[0] = new THREE.PointLight(0xffffff, 1, 0);\n    lights[1] = new THREE.PointLight(0xffffff, 1, 0);\n    lights[2] = new THREE.PointLight(0xffffff, 1, 0);\n    lights[0].position.set(0, 200, 0);\n    lights[1].position.set(200, 0, 100);\n    lights.forEach(light => scene.add(light));\n  };\n\n  const phongMaterial = color => {\n    return new THREE.MeshPhongMaterial(\n      Object.assign(\n        { emissive: 0x072534, side: THREE.DoubleSide, flatShading: true },\n        { color }\n      )\n    );\n  };\n\n  const addBeams = () => {\n    const coloredMesh = (geometry, colors) => {\n      var cubeMaterialArray = [];\n\n      // order to add materials: x+,x-,y+,y-,z+,z-\n      cubeMaterialArray.push(phongMaterial(colors[0]));\n      cubeMaterialArray.push(phongMaterial(colors[0]));\n      cubeMaterialArray.push(phongMaterial(colors[1]));\n      cubeMaterialArray.push(phongMaterial(colors[1]));\n      cubeMaterialArray.push(phongMaterial(colors[2]));\n      cubeMaterialArray.push(phongMaterial(colors[2]));\n      return new THREE.Mesh(geometry, cubeMaterialArray);\n    };\n\n    const makeGroup = (size, position, colors) => {\n      var data = {\n        ...size,\n        ...position,\n        widthSegments: 1,\n        heightSegments: 1,\n        depthSegments: 1\n      };\n      var group = new THREE.Group();\n      var geometry = new THREE.BoxGeometry(\n        data.width,\n        data.height,\n        data.depth,\n        data.widthSegments,\n        data.heightSegments,\n        data.depthSegments\n      );\n      group.add(coloredMesh(geometry, colors));\n      group.position.set(data.x, data.y, data.z);\n      return group;\n    };\n    const groups = [\n      makeGroup({ width: 1, height: 1, depth: 16 }, origin, colors),\n      makeGroup(\n        { width: 1, height: 14, depth: 1 },\n        position(origin, { y: 7.5, z: 7.5 }),\n        colors\n      ),\n      makeGroup(\n        { width: 16, height: 1, depth: 1 },\n        position(origin, { x: -7.5, z: -7.5 }),\n        colors\n      )\n    ];\n\n    groups.forEach(group => scene.add(group));\n  };\n\n  const addCorrectingTiles = () => {\n    const makeTile = ({ x, y, z }, color) => {\n      const geometry = new THREE.PlaneGeometry(1, 1, 1);\n      const mat = phongMaterial(color);\n\n      // var lineMaterial = new THREE.LineBasicMaterial( { color: 0xffffff, transparent: true, opacity: 0.5 } );\n      // scene.add( new THREE.LineSegments( geometry, lineMaterial ) );\n\n      const plane = new THREE.Mesh(geometry, mat);\n      plane.position.set(x, y, z);\n      return plane;\n    };\n    scene.add(makeTile(position(origin, { x: 1, y: 15, z: 8 }), colors[2]));\n    scene.add(makeTile(position(origin, { y: 15, z: 8 }), colors[2]));\n  };\n\n  // const addGrid = () => {\n  //   var grid = new THREE.GridHelper(100, 100);\n  //   scene.add(grid);\n  // };\n\n  // const random = (upper, lower = 0) =>\n  //   Math.floor(Math.random() * upper) + lower;\n  const isTilted = camera =>\n    Math.abs(Math.sin(camera.rotation.z)) > 0.015 &&\n    Math.abs(Math.cos(camera.rotation.z)) > 0.015;\n\n  const origin = { x: 3.5, y: 0, z: 0 };\n  const colors = [0xff6138, 0x00a388, 0x0f0f0f];\n\n  let perspectiveCamera = makePerspectiveCamera();\n  let orthographicCamera = makeOrthographicCamera();\n\n  let camera = orthographicCamera;\n  let renderer = makeRenderer();\n  let orbit;\n  addLights();\n  addBeams();\n  addCorrectingTiles();\n\n  const render = () => {\n    requestAnimationFrame(render);\n    camera = configuration.perspectiveCamera\n      ? perspectiveCamera\n      : orthographicCamera;\n    if (camera.isPerspectiveCamera) {\n      if (!orbit) {\n        orbit = new OrbitControls(camera, renderer.domElement);\n        orbit.enableZoom = false;\n      }\n    }\n    if (camera.isOrthographicCamera && isTilted(camera)) {\n      camera.rotation.z += 0.025;\n    }\n\n    renderer.render(scene, camera);\n  };\n\n  const handleClick = event => {\n    while (camera.isOrthographicCamera && !isTilted(camera)) {\n      camera.rotation.z += 0.025;\n      camera.updateProjectionMatrix();\n    }\n  };\n\n  const handleDoubleClick = event => {\n    configuration.perspectiveCamera = !configuration.perspectiveCamera;\n  };\n\n  const handleResize = event => {\n    camera.aspect = 1; //window.innerWidth / window.innerHeight;\n    camera.updateProjectionMatrix();\n\n    renderer.setSize(window.innerWidth, window.innerHeight);\n  };\n\n  const handleKeyDown = event => {\n    switch (event.keyCode) {\n      case 32:\n        handleClick(event);\n        break;\n      case 13:\n        handleDoubleClick(event);\n        break;\n      default:\n        break;\n    }\n  };\n\n  window.addEventListener(\"keydown\", handleKeyDown);\n  window.addEventListener(\"click\", handleClick);\n  window.addEventListener(\"dblclick\", handleDoubleClick);\n  window.addEventListener(\"resize\", handleResize);\n  window.addEventListener(\"orientationchange\", handleResize);\n\n  render();\n};\n","// In production, we register a service worker to serve assets from local cache.\n\n// This lets the app load faster on subsequent visits in production, and gives\n// it offline capabilities. However, it also means that developers (and users)\n// will only see deployed updates on the \"N+1\" visit to a page, since previously\n// cached resources are updated in the background.\n\n// To learn more about the benefits of this model, read https://goo.gl/KwvDNy.\n// This link also includes instructions on opting out of this behavior.\n\nconst isLocalhost = Boolean(\n  window.location.hostname === 'localhost' ||\n    // [::1] is the IPv6 localhost address.\n    window.location.hostname === '[::1]' ||\n    // 127.0.0.1/8 is considered localhost for IPv4.\n    window.location.hostname.match(\n      /^127(?:\\.(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)){3}$/\n    )\n);\n\nexport function register(config) {\n  if (process.env.NODE_ENV === 'production' && 'serviceWorker' in navigator) {\n    // The URL constructor is available in all browsers that support SW.\n    const publicUrl = new URL(process.env.PUBLIC_URL, window.location);\n    if (publicUrl.origin !== window.location.origin) {\n      // Our service worker won't work if PUBLIC_URL is on a different origin\n      // from what our page is served on. This might happen if a CDN is used to\n      // serve assets; see https://github.com/facebook/create-react-app/issues/2374\n      return;\n    }\n\n    window.addEventListener('load', () => {\n      const swUrl = `${process.env.PUBLIC_URL}/service-worker.js`;\n\n      if (isLocalhost) {\n        // This is running on localhost. Let's check if a service worker still exists or not.\n        checkValidServiceWorker(swUrl, config);\n\n        // Add some additional logging to localhost, pointing developers to the\n        // service worker/PWA documentation.\n        navigator.serviceWorker.ready.then(() => {\n          console.log(\n            'This web app is being served cache-first by a service ' +\n              'worker. To learn more, visit https://goo.gl/SC7cgQ'\n          );\n        });\n      } else {\n        // Is not local host. Just register service worker\n        registerValidSW(swUrl, config);\n      }\n    });\n  }\n}\n\nfunction registerValidSW(swUrl, config) {\n  navigator.serviceWorker\n    .register(swUrl)\n    .then(registration => {\n      registration.onupdatefound = () => {\n        const installingWorker = registration.installing;\n        installingWorker.onstatechange = () => {\n          if (installingWorker.state === 'installed') {\n            if (navigator.serviceWorker.controller) {\n              // At this point, the old content will have been purged and\n              // the fresh content will have been added to the cache.\n              // It's the perfect time to display a \"New content is\n              // available; please refresh.\" message in your web app.\n              console.log('New content is available; please refresh.');\n\n              // Execute callback\n              if (config.onUpdate) {\n                config.onUpdate(registration);\n              }\n            } else {\n              // At this point, everything has been precached.\n              // It's the perfect time to display a\n              // \"Content is cached for offline use.\" message.\n              console.log('Content is cached for offline use.');\n\n              // Execute callback\n              if (config.onSuccess) {\n                config.onSuccess(registration);\n              }\n            }\n          }\n        };\n      };\n    })\n    .catch(error => {\n      console.error('Error during service worker registration:', error);\n    });\n}\n\nfunction checkValidServiceWorker(swUrl, config) {\n  // Check if the service worker can be found. If it can't reload the page.\n  fetch(swUrl)\n    .then(response => {\n      // Ensure service worker exists, and that we really are getting a JS file.\n      if (\n        response.status === 404 ||\n        response.headers.get('content-type').indexOf('javascript') === -1\n      ) {\n        // No service worker found. Probably a different app. Reload the page.\n        navigator.serviceWorker.ready.then(registration => {\n          registration.unregister().then(() => {\n            window.location.reload();\n          });\n        });\n      } else {\n        // Service worker found. Proceed as normal.\n        registerValidSW(swUrl, config);\n      }\n    })\n    .catch(() => {\n      console.log(\n        'No internet connection found. App is running in offline mode.'\n      );\n    });\n}\n\nexport function unregister() {\n  if ('serviceWorker' in navigator) {\n    navigator.serviceWorker.ready.then(registration => {\n      registration.unregister();\n    });\n  }\n}\n","import \"./index.css\";\nimport { renderTriangle } from \"./triangle\";\n\nimport * as serviceWorker from \"./serviceWorker\";\n\nwindow.onload = () => {\n  renderTriangle();\n};\n\n// ReactDOM.render(<App />, document.getElementById('root'));\n\n// If you want your app to work offline and load faster, you can change\n// unregister() to register() below. Note this comes with some pitfalls.\n// Learn more about service workers: http://bit.ly/CRA-PWA\nserviceWorker.unregister();\n"],"sourceRoot":""}