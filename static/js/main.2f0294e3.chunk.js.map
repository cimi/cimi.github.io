{"version":3,"sources":["menu.js","triangle.js","serviceWorker.js","index.js"],"names":["gui","dat","closeOnTop","toggleHide","configuration","perspectiveCamera","add","listen","name","renderTriangle","scene","THREE","position","base","offset","x","y","z","phongMaterial","color","Object","assign","emissive","side","flatShading","isTilted","camera","Math","abs","sin","rotation","cos","origin","colors","window","innerWidth","innerHeight","set","PI","makePerspectiveCamera","orthographicCamera","lookAt","zoom","updateProjectionMatrix","makeOrthographicCamera","composer","renderer","antialias","setPixelRatio","devicePixelRatio","setSize","setClearColor","document","body","appendChild","domElement","EffectComposer","makeComposer","renderPass","RenderPass","addPass","orbit","glitchPass","GlitchPass","lights","forEach","light","addLights","makeGroup","size","data","widthSegments","heightSegments","depthSegments","group","geometry","width","height","depth","cubeMaterialArray","push","coloredMesh","addBeams","makeTile","mat","plane","addCorrectingTiles","render","requestAnimationFrame","isPerspectiveCamera","OrbitControls","enableZoom","update","isOrthographicCamera","handleClick","event","handleDoubleClick","handleResize","aspect","addEventListener","keyCode","Boolean","location","hostname","match","onload","navigator","serviceWorker","ready","then","registration","unregister"],"mappings":"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","file":"static/js/main.2f0294e3.chunk.js","sourcesContent":["import * as dat from \"dat.gui\";\n\nconst gui = new dat.GUI({\n  closeOnTop: true\n});\ndat.GUI.toggleHide();\nconst configuration = { perspectiveCamera: false };\nconst cameraController = gui.add(configuration, \"perspectiveCamera\").listen();\ncameraController.name(\"Perspective camera\");\n\nexport { configuration };\n","import * as THREE from \"three\";\nimport { EffectComposer } from \"three/examples/jsm/postprocessing/EffectComposer\";\nimport { GlitchPass } from \"three/examples/jsm/postprocessing/GlitchPass\";\nimport { RenderPass } from \"three/examples/jsm/postprocessing/RenderPass\";\n\nimport { OrbitControls } from \"three/examples/jsm/controls/OrbitControls\";\nimport { configuration } from \"./menu\";\n\nexport const renderTriangle = () => {\n  const scene = new THREE.Scene();\n\n  const position = (base, offset) => ({\n    x: (base.x || 0) + (offset.x || 0),\n    y: (base.y || 0) + (offset.y || 0),\n    z: (base.z || 0) + (offset.z || 0)\n  });\n\n  const makePerspectiveCamera = () => {\n    const perspectiveCamera = new THREE.PerspectiveCamera(\n      45,\n      window.innerWidth / window.innerHeight,\n      1,\n      5000\n    );\n    perspectiveCamera.position.set(25, 25, 25);\n    perspectiveCamera.rotation.set(-Math.PI / 4, 0, 0);\n    return perspectiveCamera;\n  };\n\n  const makeOrthographicCamera = () => {\n    const orthographicCamera = new THREE.OrthographicCamera(\n      window.innerWidth / -2,\n      window.innerWidth / 2,\n      window.innerHeight / 2,\n      window.innerHeight / -2,\n      1,\n      5000\n    );\n    orthographicCamera.position.set(30, 30, 30);\n    orthographicCamera.lookAt(new THREE.Vector3(5, 5, 5));\n    orthographicCamera.zoom = 30;\n    orthographicCamera.rotation.z = Math.PI;\n    orthographicCamera.updateProjectionMatrix();\n\n    return orthographicCamera;\n  };\n\n  const makeComposer = () => {\n    const renderer = new THREE.WebGLRenderer({ antialias: true });\n    renderer.setPixelRatio(window.devicePixelRatio);\n    renderer.setSize(window.innerWidth, window.innerHeight);\n    renderer.setClearColor(0xffff9d, 1);\n    document.body.appendChild(renderer.domElement);\n    const composer = new EffectComposer(renderer);\n    return composer;\n  };\n\n  const addLights = () => {\n    var lights = [];\n    lights[0] = new THREE.PointLight(0xffffff, 1, 0);\n    lights[1] = new THREE.PointLight(0xffffff, 1, 0);\n    lights[2] = new THREE.PointLight(0xffffff, 1, 0);\n    lights[0].position.set(0, 200, 0);\n    lights[1].position.set(200, 0, 100);\n    lights.forEach(light => scene.add(light));\n  };\n\n  const phongMaterial = color => {\n    return new THREE.MeshPhongMaterial(\n      Object.assign(\n        { emissive: 0x072534, side: THREE.DoubleSide, flatShading: true },\n        { color }\n      )\n    );\n  };\n\n  const addBeams = () => {\n    const coloredMesh = (geometry, colors) => {\n      var cubeMaterialArray = [];\n\n      // order to add materials: x+,x-,y+,y-,z+,z-\n      cubeMaterialArray.push(phongMaterial(colors[0]));\n      cubeMaterialArray.push(phongMaterial(colors[0]));\n      cubeMaterialArray.push(phongMaterial(colors[1]));\n      cubeMaterialArray.push(phongMaterial(colors[1]));\n      cubeMaterialArray.push(phongMaterial(colors[2]));\n      cubeMaterialArray.push(phongMaterial(colors[2]));\n      return new THREE.Mesh(geometry, cubeMaterialArray);\n    };\n\n    const makeGroup = (size, position, colors) => {\n      var data = {\n        ...size,\n        ...position,\n        widthSegments: 1,\n        heightSegments: 1,\n        depthSegments: 1\n      };\n      var group = new THREE.Group();\n      var geometry = new THREE.BoxGeometry(\n        data.width,\n        data.height,\n        data.depth,\n        data.widthSegments,\n        data.heightSegments,\n        data.depthSegments\n      );\n      group.add(coloredMesh(geometry, colors));\n      group.position.set(data.x, data.y, data.z);\n      return group;\n    };\n    const groups = [\n      makeGroup({ width: 1, height: 1, depth: 16 }, origin, colors),\n      makeGroup(\n        { width: 1, height: 14, depth: 1 },\n        position(origin, { y: 7.5, z: 7.5 }),\n        colors\n      ),\n      makeGroup(\n        { width: 16, height: 1, depth: 1 },\n        position(origin, { x: -7.5, z: -7.5 }),\n        colors\n      )\n    ];\n\n    groups.forEach(group => scene.add(group));\n  };\n\n  const addCorrectingTiles = () => {\n    const makeTile = ({ x, y, z }, color) => {\n      const geometry = new THREE.PlaneGeometry(1, 1, 1);\n      const mat = phongMaterial(color);\n\n      // var lineMaterial = new THREE.LineBasicMaterial( { color: 0xffffff, transparent: true, opacity: 0.5 } );\n      // scene.add( new THREE.LineSegments( geometry, lineMaterial ) );\n\n      const plane = new THREE.Mesh(geometry, mat);\n      plane.position.set(x, y, z);\n      return plane;\n    };\n    scene.add(makeTile(position(origin, { x: 1, y: 15, z: 8 }), colors[2]));\n    scene.add(makeTile(position(origin, { y: 15, z: 8 }), colors[2]));\n  };\n\n  // const addGrid = () => {\n  //   var grid = new THREE.GridHelper(100, 100);\n  //   scene.add(grid);\n  // };\n\n  // const random = (upper, lower = 0) =>\n  //   Math.floor(Math.random() * upper) + lower;\n  const isTilted = camera =>\n    Math.abs(Math.sin(camera.rotation.z)) > 0.015 &&\n    Math.abs(Math.cos(camera.rotation.z)) > 0.015;\n\n  const origin = { x: 3.5, y: 0, z: 0 };\n  const colors = [0xff6138, 0x00a388, 0x0f0f0f];\n\n  let perspectiveCamera = makePerspectiveCamera();\n  let orthographicCamera = makeOrthographicCamera();\n\n  let camera = orthographicCamera;\n  let composer = makeComposer();\n  const renderPass = new RenderPass(scene, camera);\n  composer.addPass(renderPass);\n\n  const glitchPass = new GlitchPass();\n  composer.addPass(glitchPass);\n\n  let orbit;\n  addLights();\n  addBeams();\n  addCorrectingTiles();\n\n  const render = () => {\n    requestAnimationFrame(render);\n    camera = configuration.perspectiveCamera\n      ? perspectiveCamera\n      : orthographicCamera;\n    if (camera.isPerspectiveCamera) {\n      if (!orbit) {\n        orbit = new OrbitControls(camera, composer.renderer.domElement);\n        orbit.enableZoom = false;\n        orbit.update();\n      }\n    }\n    if (camera.isOrthographicCamera && isTilted(camera)) {\n      camera.rotation.z += 0.025;\n    }\n    renderPass.camera = camera;\n    renderPass.scene = scene;\n    composer.render();\n  };\n\n  const handleClick = event => {\n    while (camera.isOrthographicCamera && !isTilted(camera)) {\n      camera.rotation.z += 0.025;\n      camera.updateProjectionMatrix();\n    }\n  };\n\n  const handleDoubleClick = event => {\n    configuration.perspectiveCamera = !configuration.perspectiveCamera;\n  };\n\n  const handleResize = event => {\n    camera.aspect = 1; //window.innerWidth / window.innerHeight;\n    camera.updateProjectionMatrix();\n\n    composer.setSize(window.innerWidth, window.innerHeight);\n  };\n\n  const handleKeyDown = event => {\n    switch (event.keyCode) {\n      case 32:\n        handleClick(event);\n        break;\n      case 13:\n        handleDoubleClick(event);\n        break;\n      default:\n        break;\n    }\n  };\n\n  window.addEventListener(\"keydown\", handleKeyDown);\n  window.addEventListener(\"click\", handleClick);\n  window.addEventListener(\"dblclick\", handleDoubleClick);\n  window.addEventListener(\"resize\", handleResize);\n  window.addEventListener(\"orientationchange\", handleResize);\n\n  render();\n};\n","// In production, we register a service worker to serve assets from local cache.\n\n// This lets the app load faster on subsequent visits in production, and gives\n// it offline capabilities. However, it also means that developers (and users)\n// will only see deployed updates on the \"N+1\" visit to a page, since previously\n// cached resources are updated in the background.\n\n// To learn more about the benefits of this model, read https://goo.gl/KwvDNy.\n// This link also includes instructions on opting out of this behavior.\n\nconst isLocalhost = Boolean(\n  window.location.hostname === 'localhost' ||\n    // [::1] is the IPv6 localhost address.\n    window.location.hostname === '[::1]' ||\n    // 127.0.0.1/8 is considered localhost for IPv4.\n    window.location.hostname.match(\n      /^127(?:\\.(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)){3}$/\n    )\n);\n\nexport function register(config) {\n  if (process.env.NODE_ENV === 'production' && 'serviceWorker' in navigator) {\n    // The URL constructor is available in all browsers that support SW.\n    const publicUrl = new URL(process.env.PUBLIC_URL, window.location);\n    if (publicUrl.origin !== window.location.origin) {\n      // Our service worker won't work if PUBLIC_URL is on a different origin\n      // from what our page is served on. This might happen if a CDN is used to\n      // serve assets; see https://github.com/facebook/create-react-app/issues/2374\n      return;\n    }\n\n    window.addEventListener('load', () => {\n      const swUrl = `${process.env.PUBLIC_URL}/service-worker.js`;\n\n      if (isLocalhost) {\n        // This is running on localhost. Let's check if a service worker still exists or not.\n        checkValidServiceWorker(swUrl, config);\n\n        // Add some additional logging to localhost, pointing developers to the\n        // service worker/PWA documentation.\n        navigator.serviceWorker.ready.then(() => {\n          console.log(\n            'This web app is being served cache-first by a service ' +\n              'worker. To learn more, visit https://goo.gl/SC7cgQ'\n          );\n        });\n      } else {\n        // Is not local host. Just register service worker\n        registerValidSW(swUrl, config);\n      }\n    });\n  }\n}\n\nfunction registerValidSW(swUrl, config) {\n  navigator.serviceWorker\n    .register(swUrl)\n    .then(registration => {\n      registration.onupdatefound = () => {\n        const installingWorker = registration.installing;\n        installingWorker.onstatechange = () => {\n          if (installingWorker.state === 'installed') {\n            if (navigator.serviceWorker.controller) {\n              // At this point, the old content will have been purged and\n              // the fresh content will have been added to the cache.\n              // It's the perfect time to display a \"New content is\n              // available; please refresh.\" message in your web app.\n              console.log('New content is available; please refresh.');\n\n              // Execute callback\n              if (config.onUpdate) {\n                config.onUpdate(registration);\n              }\n            } else {\n              // At this point, everything has been precached.\n              // It's the perfect time to display a\n              // \"Content is cached for offline use.\" message.\n              console.log('Content is cached for offline use.');\n\n              // Execute callback\n              if (config.onSuccess) {\n                config.onSuccess(registration);\n              }\n            }\n          }\n        };\n      };\n    })\n    .catch(error => {\n      console.error('Error during service worker registration:', error);\n    });\n}\n\nfunction checkValidServiceWorker(swUrl, config) {\n  // Check if the service worker can be found. If it can't reload the page.\n  fetch(swUrl)\n    .then(response => {\n      // Ensure service worker exists, and that we really are getting a JS file.\n      if (\n        response.status === 404 ||\n        response.headers.get('content-type').indexOf('javascript') === -1\n      ) {\n        // No service worker found. Probably a different app. Reload the page.\n        navigator.serviceWorker.ready.then(registration => {\n          registration.unregister().then(() => {\n            window.location.reload();\n          });\n        });\n      } else {\n        // Service worker found. Proceed as normal.\n        registerValidSW(swUrl, config);\n      }\n    })\n    .catch(() => {\n      console.log(\n        'No internet connection found. App is running in offline mode.'\n      );\n    });\n}\n\nexport function unregister() {\n  if ('serviceWorker' in navigator) {\n    navigator.serviceWorker.ready.then(registration => {\n      registration.unregister();\n    });\n  }\n}\n","import \"./index.css\";\nimport { renderTriangle } from \"./triangle\";\n\nimport * as serviceWorker from \"./serviceWorker\";\n\nwindow.onload = () => {\n  renderTriangle();\n};\n\n// ReactDOM.render(<App />, document.getElementById('root'));\n\n// If you want your app to work offline and load faster, you can change\n// unregister() to register() below. Note this comes with some pitfalls.\n// Learn more about service workers: http://bit.ly/CRA-PWA\nserviceWorker.unregister();\n"],"sourceRoot":""}